-- InProgress
IP: address space management instructions (and unit tests)
  LBU, LBE, LBUD, LBED, SBUD, SBED, SBU, LBN, TRA, TRARS, TVA, *DABT

-- TODO BUGS
SLJ instruction - U < 0200 is GRS, U+1 is always storage (we don't do that)

-- TODO implemeent
* baselib
some new instructions

* hardwarelib
need some conditional jump tests which would incur reference violation if they jumped
    both jumping (ref violation) and not jumping (no ref violation)
IP: do active base table thing
IP,IOP: UPI send/ack mechanism for IOs
IP: operations control instructions (and unit tests)
  SEND
  ACK
MSP: add support for banks dynamically allocated from native system
IP: IPC instruction for dynamic bank allocation
IP: implement standard bank switching logic
IP: interrupt processing, use standard bank switching logic
IP: IPC instruction for console communication
SCP: For starting/monitoring/stopping system, and for console communication
IOP: rework IOP, CHMOD, and downstream - lose CU's maybe
Rewrite disk (and maybe tape) devices using async IO
All Device objects: add Builder class, make constructors private
IP: UNLK instruction
IP: SPID see new info
IP: storage-to-storage instructions (and unit tests)
  BT (note special version to indicate processor idle)
  BIM
  BIC
  BIMT
  BICL
  BIML
  BN
  BBN
  BTP
  BTU
IP: string instructions (and unit tests)
  LS
  LSA
  SS
  TES
  TNES
IP: extended mode procedure call instructions (and unit tests)
  GOTO
  CALL
  LOCL
  RTN
IP: basic mode procedure call instructions (and unit tests)
  LBJ
  LIJ
  LDJ
IP: queuing instructions
  ENQ
  ENQF
  DEQ
  DEQW
  DEPOSITQB
  WITHDRAWQB
IP: activity control instructions (and unit tests)
  LD
  SD
  LPD
  SPD
  LUD
  SUD
  LAE
  UR
  ACEL
  DCEL
  SKQT
  KCHG
IP: dayclock control instructions (and unit tests)
  LRD
  SMD
  RMD
  LMC
  SDMN
  SDMS
  SDMF
  RDC
IP: system instrumentation instructions
  LBRX
  CJHE
  SJH
IP: special instructions (and unit tests)
  EX
  EXR
  DCB
IP: floating point binary instructions (and unit tests)
  FA
  FAN
  DFA
  DFAN
  FM
  DFM
  FD
  DFD
  LUF
  DFU
  LCF
  DFP,DLCF
  FEL
  FCL
  MCDU
  CDU
IP: floating point conditional jumps (requires floating point instructions to be implemented)
  JFO
  JNFO
  JFU
  JNFU
IP: fixed point decimal instructions (and unit tests)
  ADE
  DADE
  SDE
  DSDE
  DEI
  DDEI
  IDE
  DIDE
  BDE
  DEB
  EDDE
IP: search and masked search instructions (and unit tests)
  SE
  SNE
  SNG
  SG
  SW
  SNW
  MSE
  MSNE
  MSLE,MSNG
  MSG
  MSW
  MSNW
  MASL
  MASG

* minalib
unit tests for string value generation
unit tests for node references - need to check results
support special form for JGD instruction
support special form for BT instruction
support node references on LHS of $EQU statements
need to put partial-words into the dictionary - and should we allow these as expressions in j-field?
remove UndefinedReferenceDiagnostic (I think...)
use DiagnosticDirective for stuff
pick up the rest of the unit tests we need to do but haven't yet
do we need microstrings?
$USE (A.2.8) specifies base register to use if none given
add test cases for interrupts (many of them already marked TODO)
float values - firm this up (how do we support it)
data generation - floats
can we do implicit base register (and do it right)?  also with the $LIT directive...
make sure we don't propagate flagged attribute in any of the operators
support user-defined functions
allow expression list inside literal which is part of expression e.g., ((005, 007) + 12)
functions
  $ILCN
  $L0
  $L1
  $LCB
  $LCFV
  $LCN
  $SSS
  $LCV
  $NODE (an empty node - this is maybe a built-in value, not a function?)
directives
  $END directive on top-level code (do we require it?)
  $EQUF
  $USE (implicit base register)
  $INSERT (maybe)
  $BASE (maybe)
  $IF / $ELSE / $ELSF / $ENDF
  $DO / $ENDD
  $REPEAT / $ENDR
  $FORM
  $GEN
  $INCLUDE (what does this mean for us?)
  $INFO finish the various groups we're going to implement

* Mina - wrapper around minalib

* Exec - using Mina (or minalib, but hopefully mina)
