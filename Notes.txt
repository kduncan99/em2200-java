-- InProgress
IP: implement standard bank switching logic
IP: address space management instructions unit tests
IP: basic mode procedure call instructions (and unit tests)
  LBJ, LIJ, LDJ
IP: extended mode procedure call instructions (and unit tests)
  GOTO, CALL, LOCL, RTN

-- TODO BUGS
BaseFunctions - need to make data banks extended mode
SLJ instruction - U < 0200 is GRS, U+1 is always storage (we don't do that)
We've broken breakpoint on fetch due to not developing absolute addresses anymore.
BankDescriptor seems to take a very long time to create from storage... why?
Test code loads successive 512 word banks at 1024 word offsets - is this right?

-- TODO implement
* baselib
some new instructions

* hardwarelib
Change extended mode dbanks to start at lower-limit 0 - this *should* work...
For basic mode, no need really to test the bank limits on every fetch - set it once, then save it and use it...
  what to do when we run off the end of the bank?
need some conditional jump tests which would incur reference violation if they jumped
    both jumping (ref violation) and not jumping (no ref violation)
IP,IOP: UPI send/ack mechanism for IOs
IP: operations control instructions (and unit tests)
  SEND
  ACK
MSP: add support for banks dynamically allocated from native system
IP: IPC instruction for dynamic bank allocation
IP: interrupt processing, use standard bank switching logic
IP: IPC instruction for console communication
SystemControlProcessor: For starting/monitoring/stopping system, and for console communication
IOP: rework IOP, CHMOD, and downstream - lose CU's maybe
Rewrite disk (and maybe tape) devices using async IO
All Device objects: add Builder class, make constructors private
IP: UNLK instruction
IP: SPID see new info
IP: storage-to-storage instructions (and unit tests)
  BT (note special version to indicate processor idle)
  BIM
  BIC
  BIMT
  BICL
  BIML
  BN
  BBN
  BTP
  BTU
IP: string instructions (and unit tests)
  LS
  LSA
  SS
  TES
  TNES
IP: queuing instructions
  ENQ
  ENQF
  DEQ
  DEQW
  DEPOSITQB
  WITHDRAWQB
IP: activity control instructions (and unit tests)
  LD
  SD
  LPD
  SPD
  LUD
  SUD
  LAE
  UR
  ACEL
  DCEL
  SKQT
  KCHG
IP: dayclock control instructions (and unit tests)
  LRD
  SMD
  RMD
  LMC
  SDMN
  SDMS
  SDMF
  RDC
IP: system instrumentation instructions
  LBRX
  CJHE
  SJH
IP: special instructions (and unit tests)
  EX
  EXR
  DCB
IP: floating point binary instructions (and unit tests)
  FA
  FAN
  DFA
  DFAN
  FM
  DFM
  FD
  DFD
  LUF
  DFU
  LCF
  DFP,DLCF
  FEL
  FCL
  MCDU
  CDU
IP: floating point conditional jumps (requires floating point instructions to be implemented)
  JFO
  JNFO
  JFU
  JNFU
IP: fixed point decimal instructions (and unit tests)
  ADE
  DADE
  SDE
  DSDE
  DEI
  DDEI
  IDE
  DIDE
  BDE
  DEB
  EDDE
IP: search and masked search instructions (and unit tests)
  SE
  SNE
  SNG
  SG
  SW
  SNW
  MSE
  MSNE
  MSLE,MSNG
  MSG
  MSW
  MSNW
  MASL
  MASG

* minalib
unit tests for string value generation
unit tests for node references - need to check results
support special form for JGD instruction
support special form for BT instruction
support node references on LHS of $EQU statements
need to put partial-words into the dictionary - and should we allow these as expressions in j-field?
remove UndefinedReferenceDiagnostic (I think...)
use DiagnosticDirective for stuff
pick up the rest of the unit tests we need to do but haven't yet
do we need microstrings?
$USE (A.2.8) specifies base register to use if none given
add test cases for interrupts (many of them already marked TODO)
float values - firm this up (how do we support it)
data generation - floats
can we do implicit base register (and do it right)?  also with the $LIT directive...
make sure we don't propagate flagged attribute in any of the operators
support user-defined functions
allow expression list inside literal which is part of expression e.g., ((005, 007) + 12)
functions
  $ILCN
  $L0
  $L1
  $LCB
  $LCFV
  $LCN
  $SSS
  $LCV
  $NODE (an empty node - this is maybe a built-in value, not a function?)
directives
  $END directive on top-level code (do we require it?)
  $EQUF
  $USE (implicit base register)
  $INSERT (maybe)
  $BASE (maybe)
  $IF / $ELSE / $ELSF / $ENDF
  $DO / $ENDD
  $REPEAT / $ENDR
  $FORM
  $GEN
  $INCLUDE (what does this mean for us?)
  $INFO finish the various groups we're going to implement

* Mina - wrapper around minalib

* Exec - using Mina (or minalib, but hopefully mina)
Subsystems:
  Init
  Console (can we farm this out to SCP?)
  CoreScheduler
  JobScheduler
  IO
  MFD
  ProgFileSystem
  Facilities
  RSI
  Spooler
  Loader (load, swap, etc)
  MemoryMgr
  TIP
  CSI
